# Graph Representation Library.

The purpose of this library is to define unique Graph defenition structure for the whole RD-Switchboard 
Inference Engene project. That will allow us to keep code clean and will make sure what different Enginge 
modules will be compatible with each one.

The Graph library will define the Graph shape as well as properties names of the Graph.

#### Graph class

A Graph is represented as a selection of Graph Schema, Graph Nodes and Graph Relationships. The final Graph 
class can have unlimited numver of each object, and the whole structure will only be limited by the meory of
the server. Howether, it migth be impossible to store big graphs in the database per one trasaction, 
so Graph Import or Export Libraries shoud be smart enoug to process the Graph in a couple transactions 
if necessery. 

For a Import process, usually we will generate one Graph object per one OAI:PMH file, because, by the nature of 
OAI:PMH Harvesting mechaninc, the number of records in one file is usually limited by 100 or 500 records.

#### Minimum Graph Information

Each Graph in the RD-Switchboard Database must define, at least `source`, `type` and a unique `key` for the node.
This information is sufficient to unique identify the node within our Graph database. The node also must have a `title` 
and some other identification properties, however they are not mandatory for the aggrigation phase, because some
nodes can be united at the metadata harmonization process.

#### Graph Schema

All required indexes and unique indexes (constraints) must be stored as a GraphSchema object. The Graph Import program will make
sure what each index or constraint will be imported only once, so it is save to define same Schema in a different Graph Objects.

Each Graph Schema must define a `index` and a `key` names of the index. The `index` can be either Graph Node Source or Type name, 
while `key` will be property name. The default property name is `GraphUtils.PROPETY_KEY`. A special flag, `unique` can be set to 
define an unique index (known as constraint). By default all indexes are unique 

Examples:


```java
Graph graph = new Graph();

// will define ands:key unique index
GraphSchema schema = new GraphSchema(GraphUtils.SOURCE_ANDS, GraphUtils.PROPERTY_KEY, true);
graph.addSchema(schema);

// the index can also be defined without creating a variable
graph.addSchema(new GraphSchema()
	.withIndex(GraphUtils.SOURCE_CROSSREF)
	.withKey(GraphUtils.PROPERTY_DOI)
	.withUnique(false);

// to generate a unique index on `key` property you can use short form
graph.addSchema(new GraphSchema(GraphUtils.TYPE_KEY, true));
```

#### Graph Key

A special class GraphKey is used to genreate unique key for the node. Same GraphKey object will be used to define 
unique Graph Node and to find a Start or End of the Relationship Relationship. The Nodes and Relationships will 
always store a copy of the GraphKey object, so it will be safe to use Graph Node Key object to indicate Start or 
End of Relationship.

Each GraphKey require to have an `index` name of the object, a `key` name and a key `value`. The `index` and `key` names 
must be same as any existng unique index in the GraphScheme. However, library will not check that existance, because 
actual index could be defined before any import. It will try to resolve the node even if index does not exists and that 
will make import process much slower. The default name for a index `key` is `GraphUtils.PROPERTY_KEY` and can be ommited 
for a standart index.

Examples:

```java
// To generate a key for a crossref:doi index:
GraphKey key = new GraphKey(GraphUtils.SOURCE_CROSSREF, GraphUtils.PROPERTY_DOI, doi);

// The index can be generated by using a chain-calls.
// this call to withKey can be ommited because the GraphUtils.PROPERTY_KEY is deafult `key` property name
GraphKey key2 = new GraphKey()
	.withIndex(GraphUtils.SOURCE_ANDS)
	.withKey(GraphUtils.PROPERTY_KEY) 
	.withValue(andsKey); 
```

#### Graph Node

GraphNode is a main class of the Graph Library and will contain information about single Graph Node. There 
could be couple Graph Nodes related to the same record within the Graph. In this case, only first Node will create 
a record and remaining nodes will add a data to it. However, even if such behaviour is allowed, we would advice to
avoid that as much as possible, because this will increase import time. 

Each Graph Node must have, at least key, source and type. There is also number of other properties, what can be added to the node. 
All existing property names are defined in GraphUtils as one of `PROPERTY_*` constant, all existing sources are defined in 
GraphUtils as one of `SOURCE_*` constant and all existing sources are defined in GraphUtils as one of `TYPE_*` constant.

The Graph Node property is actually a set of different variables and will accept list of collection of valus as well as a single value.
The values can also be added to already existing property, and the GraphNode object will make sure what the added values are unique. 
However, all added values must have same type, of function will fail. Use addPropery function to either create new property or add a 
value to a existing property. Use setProperty function, to discard the existing property value, if any, and init it with a new property.

To generate a Node, either chain-call form or more traditional form can be used (or combination of both). GraphNode does not define
any order in witch properties must be stored.

Graph Node can have more that one key attached. In this case, one of the keys will be used as primary and will serve to unique identify
the node and others will be used as a indexes.

Examples:

```java
// create a graph node with chain-call style
GrahNode node = new GraphNode()
	.withKey(GraphUtils.SOURCE_ANDS, GraphUtils.PROPERTY_KEY, andsKey)
	.withSource(GraphUtils.SOURCE_ANDS)
	.withType(GraphUtils.TYPE_DATASET);

// add index to the node
node.addIndex(new GraphKey(GraphUtils.SOURCE_ANDS, GraphUtils.PROPERTY_DOI, recordDoi);

// add some other properties
node.addProperty(GraphUtils.PROPERTY_TILE, recordTitle);
```

#### Graph Relationship

GraphRelationship defines a relationship between two nodes. All Graph Relationships are stored separatly from the 
Graph Nodes, because it is possible what single Graph will not define all existing Nodes. It is also possible for a 
Graph to store some Relationships to Nodes, what does not exists in the Graph but should exist in the database. In 
such case the Graph import program will try to resolve this nodes by the `start` or `end` `key` of the relationsip. 
If nodes can not be resolved at the import process, the unresolved relationship will be stored in the memory until 
both Nodes will exist in the Graph database. However, if the program will be terminated before this will happen, 
the unresolved relationships will be lost so we would advice to avoid such behaviour, if possible. The import program 
will always import all existing nodes and then will try and resolve all relationships to minimize the chance this 
could happen.

To generate a relationhip, you must provode relationship type and a keys for a start and end node of the relationsip.
You also can provide additional relationship parameters in a same facion as node parameters. All graph Relationships 
tipes are defined  in GraphUtils as one of `RELATIONSHIP_*` constant, but they are not as important as properties names
and you can use any string you want. All relationships typs will be replaced with `GraphUtils.RELATIONSHIP_KNOWN_AS` or 
`GraphUtils.RELATIONSHIP_RELATED_TO` relationship types upon a metadata harmonization process and only one relationsip
in any direction will be saved.

Examples:

```java
// create a graph node with chain-call style
GrahRelationship rel = new GrahRelationship()
	.withType(GraphUtils.RELATIONSHIP_RELATED_TO)
	.withStart(node.getKey)
	.withEnd(GraphUtils.SOURCE_CROSSREF, GraphUtils.PROPERTY_DOI, GraphUtils.extractDoi(referencedDoi));
```


#### Graph Utils

GraphUtils is a static class, what defines all contants for a Graph. It defines all possible Graph source and type strings, 
properties and relationships names, etc. It also defines some static functions for extracting or generating standartised
URL's, DOI, ORCID ID and Scopus ID.
